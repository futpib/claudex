import os from 'node:os';
import path from 'node:path';
import fs from 'node:fs/promises';
import envPaths from 'env-paths';
import { isErrnoException } from './utils.js';

const paths = envPaths('claudex', {
	suffix: '',
});

const claudexMemoryDirectoryPath = path.join(paths.config, 'CLAUDE.md.d');

const claudeCodeMemoryPath = path.join(os.homedir(), '.claude', 'CLAUDE.md');

function prettifyPath(filePath: string) {
	const homeDir = os.homedir();

	if (filePath.startsWith(homeDir)) {
		filePath = filePath.replace(homeDir, '~');
	}

	return filePath;
}

const doNotEditThisFileMessage = [
	'Do not edit this file directly. It is automatically generated by claudex.',
	`Edit files in ${prettifyPath(claudexMemoryDirectoryPath)} instead.`,
].join('\n');

async function fileExists(filePath: string): Promise<boolean> {
	try {
		await fs.access(filePath);
		return true;
	} catch (error) {
		if (isErrnoException(error) && error.code === 'ENOENT') {
			return false;
		}

		throw error;
	}
}

async function getFilesInClaudexMemoryDirectory(): Promise<string[]> {
	const entriesInMemoryDirectory = await fs.readdir(claudexMemoryDirectoryPath, {
		withFileTypes: true,
	});

	const filesInMemoryDirectory = (
		entriesInMemoryDirectory
			.filter(entry => (
				(
					entry.isFile()
					|| entry.isSymbolicLink()
				)
				&& entry.name.endsWith('.md')
			))
			.sort((a, b) => a.name.localeCompare(b.name))
			.map(entry => path.join(entry.parentPath, entry.name))
	);

	return filesInMemoryDirectory;
}

async function shouldBackupClaudeCodeMemory(): Promise<boolean> {
	try {
		const content = await fs.readFile(claudeCodeMemoryPath, 'utf8');
		return !content.includes(doNotEditThisFileMessage);
	} catch (error) {
		if (isErrnoException(error) && error.code === 'ENOENT') {
			return false;
		}

		throw error;
	}
}

async function backupClaudeCodeMemory(): Promise<void> {
	const backupPath = path.join(path.dirname(claudeCodeMemoryPath), 'CLAUDE.md.bak');

	if (await fileExists(backupPath)) {
		const timestamp = new Date().toISOString().replaceAll(/[:.]/g, '-');
		const timestampedBackupPath = `${backupPath}.${timestamp}`;
		await fs.rename(claudeCodeMemoryPath, timestampedBackupPath);
	} else {
		await fs.rename(claudeCodeMemoryPath, backupPath);
	}
}

export async function createClaudeCodeMemory() {
	const filesInMemoryDirectory = await getFilesInClaudexMemoryDirectory();

	if (await shouldBackupClaudeCodeMemory()) {
		console.warn('Backing up existing CLAUDE.md file...');
		await backupClaudeCodeMemory();
	}

	await fs.writeFile(claudeCodeMemoryPath, (async function * () {
		yield doNotEditThisFileMessage;
		yield '\n\n';

		for (const file of filesInMemoryDirectory) {
			yield `# ${prettifyPath(file)}\n\n`;

			const fileContent = await fs.readFile(file, 'utf8');
			yield fileContent;
			yield '\n\n';
		}
	})());
}
